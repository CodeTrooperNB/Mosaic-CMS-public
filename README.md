# Mosaic CMS

Mosaic CMS is a Rails-based, admin-first content management system designed around reusable, schema-driven "Pods" (content blocks) that can be linked and ordered on Pages. It ships with a modern stack (Hotwire, Tailwind v4), role-based admin, and an SVG/icon pipeline. The codebase is prepared for eventual extraction into a mountable engine under the Admin namespace.

- Status: Active development (Phase 3–5 features in place)
- License: Proprietary/internal (update as appropriate)

## Features at a glance
- Admin area under /admin with authentication (Devise) and authorization (Pundit)
- Dashboard and placeholder CRUD pages for Pages and Pods
- Pods stored in Postgres as JSONB; definitions provided via YAML schemas
- Page–Pod linking with ordered positions (PagePod join model)
- Hotwire (turbo-rails, stimulus-rails), RubyUI components
- Tailwind CSS v4 CLI and esbuild for assets; propshaft for serving
- Inline SVG pipeline with helper methods for admin icons and logos
- FriendlyId slugs on Page; supports manual slugs and auto-generation
- Sidekiq + Redis configured; web UI mounted at /admin/sidekiq (see routes)


## Tech stack
- Ruby 3.4.2, Rails 8.0.2
- Database: PostgreSQL
- Caching/Jobs: Redis + Sidekiq
- Assets: propshaft, esbuild (JavaScript), Tailwind CSS v4 CLI (CSS)
- Hotwire: turbo-rails, stimulus-rails
- Views: ERB templates for admin and Devise screens
- Auth: Devise (admin users), Pundit for authorization
- Rich content: ActionText and ActiveStorage
- Icons: inline_svg, svg_optimizer

Key Mosaic gems are grouped in the Gemfile under “MOSAIC CMS GEMS”.


## Prerequisites
- PostgreSQL available locally (via service or Docker) and reachable via DATABASE_URL or config/database.yml
- Redis running (for Sidekiq and Rails cache store)
- Node.js and Yarn (for esbuild and Tailwind v4 CLI)

Recommended versions:
- Node 18+
- Yarn 1.x or corepack-enabled Yarn 3+


## Getting started

1) Install dependencies
- bundle install
- yarn install

2) Prepare the database
- bin/rails db:prepare

3) Build assets (once) or start watchers
- JS (esbuild): yarn build
- CSS (Tailwind v4): yarn build:css

4) Run the app (with watchers)
- bin/dev
  - Uses Procfile.dev to start web server, js, and css watchers

By default, admin is available at /admin. Devise auth is mounted under /admin/auth. If you don’t have an admin user yet, create one via Rails console:

- bin/rails c
- AdminUser.create!(email: "admin@example.com", password: "password", password_confirmation: "password", first_name: "Admin", last_name: "User", role: :admin)

Then sign in at /admin/auth/sign_in.


## Configuration notes
- Devise configuration: config/initializers/devise.rb
- Admin base controller: app/controllers/admin/admin_controller.rb (enforces authenticate_admin_user! and role gate)
- Admin layout: app/views/layouts/admin/admin.html.erb (ERB)
- Routes: config/routes.rb (admin namespace under /admin; Sidekiq mounted at /admin/sidekiq in dev)
- SVG helper: app/helpers/admin/svg_helper.rb
  - admin_svg(path, options={}) for direct paths under app/assets/images/**
  - admin_icon(name, options={}) convenience for admin icons under admin/icons/admin
  - mosaic_logo(name, options={}) for logo assets under admin/logos
  - status_icon/status_action helpers for semantics
  - Caveat: admin_icon expects a bare icon name (e.g., "home"); use admin_svg for explicit paths to avoid double-prefixing

Environment variables
- DATABASE_URL or config/database.yml for Postgres
- REDIS_URL for Sidekiq/caching
- RAILS_ENV (development by default)
- ActiveStorage service config in config/storage.yml (ensure bucket/service if enabling in non-dev)


## Images and Bunny CDN
Mosaic uses Bunny CDN to serve images and ActiveStorage variants in production.

Helpers are provided to generate canonical CDN URLs for images used in pods:
- pod_image_tag(data_or_value, field = nil, variant: "desktop"|"mobile", alt: nil, **html_options)
- pod_image_url(data_or_value, field = nil, variant: "desktop"|"mobile")

How it works:
- The helpers normalize the image field (from the pod's JSONB definition) and resolve either a direct URL or an ActiveStorage attachment.
- Under the hood, they call serve_image_remote_url from BunnyImageHelper, which builds URLs using Settings.bunny.cdn, e.g. https://your-pull-zone.b-cdn.net/<blob_or_variant_key>.
- Variants are generated server-side (resize_to_limit/fill), and the resulting variant keys are also served via the Bunny CDN URL.

Boilerplate pod templates generated by the pods generator already use pod_image_tag for image fields, so CDN-backed image tags are used by default.

Configuration:
- Set Settings.bunny.cdn to your Bunny Pull Zone base URL (e.g., https://example.b-cdn.net).
- Ensure ActiveStorage is configured and images are uploaded as blobs so their keys/variants are accessible.


## Project structure highlights
- Admin controllers: app/controllers/admin/**
- Admin views and partials: app/views/admin/** (ERB for most admin pages; Devise screens under app/views/admin/devise)
- SVG/icon assets: app/assets/images/admin/**
- Models for core content: Page, Pod, PagePod (join/position)
- Services: Admin::PodSchemas for loading YAML pod definitions
- Generators: lib/generators/pods (generate view partials from pod definitions)
- Docs: docs/ contains roadmap and a fallback pod_definitions.yml


## Blog management
The Rails 8 blog engine ships with an admin-first workflow and public views. Use these conventions to author and publish content.

### Admin workflow
- Navigate to **Admin → Blogs** from the sidebar. The index shows total, visible, published, and scheduled counts plus filters for category, tag, visibility, and publish state.
- Click **New Blog** to create a post. Provide a title (slug auto-generates if left blank), optional excerpt, and rich text content via the TinyMCE editor.
- Use the **Author** field to set a custom byline (defaults to the signed-in admin’s name when left blank).
- Supply optional **SEO Title** and **SEO Description** to control the `<title>` tag and meta description used on the public blog page.
- Choose an existing category from the dropdown, or enter a value in **Create New Category** to add one on save. The new category is automatically assigned to the post.
- Assign tags by checking the existing list. To create new tags inline, supply comma-separated values in **Create New Tags**; they are created (case-insensitive) and linked after save.
- Visibility and scheduling:
  - Enable **Display on frontend** to mark a post as eligible for the public site.
  - **Publish at** defaults to the current timestamp when left blank. Set a future datetime to schedule upcoming posts while keeping them hidden until that moment.
  - Posts remain hidden from the frontend if visibility is off or the publish time is in the future.
- The show view displays status badges (Published, Scheduled, Hidden) and provides edit/delete actions.
- Reader comments are listed on the admin show page with controls to hide/show or delete individual submissions.

### Public pages
- Blog routes are exposed at `/blogs` (index) and `/blogs/:slug` (show).
- The index accepts optional filters:
  - `?category=category-slug` limits to a category.
- `?tags=tag-slug&tags=another` matches any selected tags.
- Only posts with `visible: true` and `published_at` not in the future are rendered. Content is delivered via ActionText, so formatting and inline images added in TinyMCE appear on the frontend.
- Readers can post comments from the blog show page by providing a name (email optional). Comments are immediately visible unless an admin hides them; hidden comments remain stored but are excluded from the public page.
- When present, a blog’s SEO title/description set the `<title>` tag and meta description rendered to search engines and power the headline/subheading on the public show view.


## Pods and schemas (overview)
Mosaic’s content model revolves around Pods: reusable JSONB-backed content blocks defined by YAML schemas. Pods can be linked and ordered on Pages through PagePods. A quick summary:
- Definitions live in config/pod_definitions.yml (project-specific). If absent, docs/pod_definitions.yml is used as a fallback.
- Admin::PodSchemas is a singleton service that loads and validates the schema file and exposes available_types, schema_for(type), and categories.
- Rake tasks are provided to validate and reload schemas during development:
  - bin/rails admin:pod_definitions:validate
  - bin/rails admin:pod_definitions:reload
- A generator can produce ERB display partials for each pod type:
  - bin/rails generate pods
  - Output: app/views/pods/shared/_<pod_key>.html.erb (one per pod)

For a complete guide with examples, see POD_GUIDE.md in the project root.


## Running tests
- bin/rails test

A minimal test helper exists at test/test_helper.rb and an example helper test can be found at test/helpers/admin/svg_helper_test.rb. For view/helper tests that rely on inline SVG helpers, include InlineSvg::ActionView::Helpers in the test case.


## Development workflow tips
- Tailwind v4 CLI compiles CSS; re-run yarn build:css after editing app/assets/stylesheets/form_utility.scss.
- Follow docs/dev_style_guide.md for admin UI patterns. Ensure dark mode parity.
- Prefer using the utility classes defined under form_utility.scss rather than ad-hoc Tailwind to keep consistency.
- For authorization, prefer policy_scope(Model) and authorize Model for index actions per Pundit conventions.


## Deployment notes
- Ensure DATABASE_URL and REDIS_URL are set in the environment.
- Precompile assets using the same Tailwind/JS steps (or via bin/rails assets:precompile if integrated).
- Protect /admin/sidekiq with authentication in non-dev environments.
- Ensure ActiveStorage service credentials and storage backend are configured if rich media is enabled.


## FriendlyId slugs
- Page uses FriendlyId to generate slugs from title when slug is blank and to resolve by slug or ID in controllers via Page.friendly.find.
- Manual slugs are respected. No history table is enabled by default.


## License and contribution
- Update LICENSE as appropriate.
- Contributions should follow the UI Style Guide and the conventions in this README. Open PRs with clear screenshots for any admin UI changes (light and dark mode).
